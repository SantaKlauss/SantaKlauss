//дает возможность ссылаться на классы, которые находятся в пространстве имен System, 
//так что их можно использовать, не добавляя System. перед именем типа.
using System;
//Содержит интерфейсы и классы, определяющие универсальные коллекции, 
//которые позволяют пользователям создавать строго типизированные коллекции, 
//обеспечивающие повышенную производительность и безопасность типов 
//по сравнению с неуниверсальными строго типизированными коллекциями.
using System.Collections.Generic;
//Пространство имен System.ComponentModel содержит классы, реализующие поведение 
//компонентов и элементов управления во время проектирования и выполнения.Данное 
//пространство имен включает базовые классы и интерфейсы, предназначенные для реализации 
//преобразователей атрибутов и типов, для привязки к источникам данных и для лицензирования
//компонентов.
using System.ComponentModel;
//Пространство имен System.Data обеспечивает доступ к классам, которые представляют архитектуру
//ADO.NET.Архитектура ADO.NET позволяет создавать компоненты, эффективно работающие с данными 
//из различных источников.
using System.Data;
//обеспечивает доступ к базовым функциональным возможностям графического интерфейса GDI+
using System.Drawing;
//Пространство имен System.Linq содержит классы и интерфейсы, которые поддерживают LINQ.
using System.Linq;
//Пространство имен содержит классы, представляющие ASCII и Unicode 
//кодировок; абстрактные базовые классы для преобразования блоков символов
//и из блоков байтов
using System.Text;
// содержит классы для создания приложений Windows, которые позволяют наиболее эффективно 
//использовать расширенные возможности пользовательского интерфейса, 
//доступные в операционной системе Microsoft Windows
using System.Windows.Forms;

// объявления области, которая содержит набор связанных объектов. Можно использовать 
//пространство имён для организации элементов кода, а также для создания глобально 
//уникальных типов.
namespace Gricenko07
{
    //Определения класса с именем Form1
    public partial class Form1 : Form
    {
        //конструктор класса формы
        public Form1()
        {
            //Обязательный метод ля поддержки конструктора - НЕ ИЗМЕНЯЙТЕ СОДЕРЖИМОЕ ДАННОГО 
            //МЕТОДА ПРИ ПОМОЩИ РЕДАКТОРА КОДА 
            InitializeComponent();
        }
        //Модификатор static используется для объявления статического члена
        //Объявляем 2 переменные
        static int a = 50, b = 2;

        //Ключевое слово float обозначает простой тип, используемый для хранения 32-разрядных 
        //значений с плавающей запятой
        //Указываем парамнгтры для функции
        // Функция вычисления значений координат
        private void func(float f, int k, out float x, out float y)
        {
            //Для 2 координат X и Y
            x = (float)((a * (1 + b * (Math.Cos(k * f))) * Math.Cos(f)));
            y = (float)((a * (1 + b * (Math.Cos(k * f))) * Math.Sin(f)));
        }
        //Нажатие на кнопку выход
        private void btnExit_Click(object sender, EventArgs e)
        {
            //Закрытие формы
            Close();
        }

        // Событие происходит при перемещении ползунка с помощью мыши или клавиатуры.
        private void scrb_Scroll(object sender, ScrollEventArgs e)
        {
            //Выводим в метку текст 
            lblk.Text = String.Concat("k = ", (scrk.Value).ToString());
        }
        //Кнопка рисования
        private void btnDraw_Click(object sender, EventArgs e)
        {
            //переменная k = уровню полосы прокрутки
            int k = scrk.Value;
            //Высота и точки для построяния 
            float h = 0.03f, k_max = 0, tt, x1, y1, x2, y2;
            // Определение масштаба
            for (float f = 0; f <= 2 * Math.PI; f = f + h)
            {
                //Функция с входными и выходными параметрами
                func(f, k, out x2, out y2);
                if (f == 0) k_max = (x2 > y2) ? x2 : y2;
                else
                {
                    //На тернарную операцию накладываются дополнительные ограничения, связанные с 
                    //типобезопасностью. Выражения 1 и 2 должны быть одного типа. 
                    tt = (x2 > y2) ? x2 : y2;
                    k_max = (tt > k_max) ? tt : k_max;
                }
            }
            //На тернарную операцию накладываются дополнительные ограничения, связанные с 
            //типобезопасностью. Выражения 1 и 2 должны быть одного типа. 
            int pict_size = (pctDraw.Width < pctDraw.Height) ? pctDraw.Width : pctDraw.Height;
            pict_size /= 2;
            // Подготовка к рисованию
            //Создаем объект Graphics для элемента управления.
            Graphics g = pctDraw.CreateGraphics();
            //Отчищаем поверхность рисования
            g.Clear(Color.White);
            //Применяем заданную операцию масштабирования к матрице преобразования данного 
            //объекта Graphics путем ее добавления перед матрицей преобразования объекта.
            g.ScaleTransform(pict_size / (float)k_max, pict_size / (float)k_max);
            //Изменяем начало системы координат путем добавления заданного сдвига перед 
            //матрицей преобразования данного объекта Graphics.
            g.TranslateTransform(pctDraw.Width / 2, pctDraw.Height / 2,
            System.Drawing.Drawing2D.MatrixOrder.Append);
            //Определяем объект, используемый для рисования прямых линий и кривых задем ему цвет
            Pen p = new Pen(Color.Red);
            // Оси координат
            g.DrawLine(p, -pctDraw.Width / 2, 0, pctDraw.Width / 2, 0);
            g.DrawLine(p, 0, -pctDraw.Height / 2, 0, pctDraw.Height / 2);
            // Рисование графика функции
            //Pen = зеленый
            p.Color = Color.Green;
            //Функция с входными и выходными параметрами
            func(0, k, out x1, out y1);

            //Ключевое слово float обозначает простой тип, используемый для хранения 32-разрядных 
            //значений с плавающей запятой
            float xmax = 0, ymax = 0;
            // Определение масштаба
            for (float f = h; f <= 2 * Math.PI + h; f = f + h)
            {
                //Функция с входными и выходными параметрами
                func(f, k, out x2, out y2);
                //Проводим линию, соединяющую две точки, задаваемые парами координат.
                g.DrawLine(p, x1, y1, x2, y2);
                //Локальные переменные
                x1 = x2;
                y1 = y2;
                //На тернарную операцию накладываются дополнительные ограничения, связанные с 
                //типобезопасностью. Выражения 1 и 2 должны быть одного типа. 
                xmax = (x1 > xmax) ? x1 : xmax;
                ymax = (y1 > ymax) ? y1 : ymax;
            }
            // Подпись осей координат
            //Рисуем заданную текстовую строку в заданном месте с помощью определяемых объектов 
            //Brush и Font, используя атрибуты форматирования заданного формата StringFormat.
            g.DrawString((xmax).ToString(), new System.Drawing.Font("Arial", 8), new
            SolidBrush(Color.Black), xmax, 0);
            ////Рисуем заданную текстовую строку в заданном месте с помощью определяемых объектов 
            //Brush и Font, используя атрибуты форматирования заданного формата StringFormat.
            g.DrawString((ymax).ToString(), new System.Drawing.Font("Arial", 8), new
            SolidBrush(Color.Black), 0, -ymax);
        }
    }
}
